@page "/chat"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.SignalR.Client
@using ChatApp.Services
@using Microsoft.AspNetCore.Authorization
@using ChatApp.Models
@using ChatApp.Components.Chat
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ChatStateService ChatState
@inject IServiceScopeFactory ScopeFactory
@inject IHttpContextAccessor HttpContextAccessor
@inject IChatMessageService ChatMessageService
@inject IJSRuntime JSRuntime
@using Microsoft.AspNetCore.Identity
@inject UserManager<ChatApp.Data.ApplicationUser> UserManager
@attribute [Authorize]
@implements IAsyncDisposable

<PageTitle>Chat</PageTitle>

<div class="chat-container">
    <!-- Sidebar -->
    <ConversationList Conversations="Conversations" SelectedConversation="SelectedConversation"
        CurrentUserId="@currentUserId" OnlineUsers="OnlineUsers" AllUsers="AllUsers"
        OnConversationSelected="OnConversationSelected" OnStartNewChat="OnStartNewChat" />

    <!-- Main Chat Area -->
    <div class="chat-main-area">
        @if (IsNewChatMode)
        {
            <NewChatView AllUsers="AllUsers" OnlineUsers="OnlineUsers" SelectedUsers="NewChatSelectedUsers"
                IsAddingParticipants="IsAddingParticipants" IsConnected="IsConnected" OnToggleUser="OnToggleNewChatUser"
                OnStart="OnStartChat" OnFileUpload="OnFileUpload" />
        }
        else if (SelectedConversation != null)
        {
            <ActiveChatView @ref="activeChatView" Conversation="SelectedConversation" IsConnected="IsConnected"
                OnToggleDetails="ToggleDetails" OnSend="HandleSend" OnFileUpload="OnFileUpload" OnStartEdit="StartEdit"
                OnDelete="DeleteMessage" OnSaveEdit="SaveEdit" OnCancelEdit="CancelEdit" OnReply="HandleReply"
                OnToggleReaction="HandleToggleReaction" />

            <ChatDetailsModal IsOpen="IsDetailsOpen" Conversation="SelectedConversation" AllUsers="AllUsers"
                OnlineUsers="OnlineUsers" CurrentUserId="@currentUserId" OnClose="ToggleDetails"
                OnAddPeople="AddUserToCurrentChat" />

            <DeleteConfirmationModal IsOpen="IsDeleteConfirmOpen" Message="MessageToDelete" OnConfirm="ConfirmDelete"
                OnCancel="CancelDelete" />
        }
        else
        {
            <div class="d-flex flex-column align-items-center justify-content-center h-100 text-muted">
                <p class="fs-4">Select a conversation or start a new one.</p>
            </div>
        }
    </div>
</div>

@if (IsNotificationVisible)
{
    <div class="toast-notification">
        <div class="d-flex align-items-center justify-content-between">
            <span>@NotificationMessage</span>
            <button class="btn-close btn-close-white ms-3" @onclick="CloseNotification"></button>
        </div>
    </div>
}

<style>
    /* Global Toast */
    .toast-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: var(--accent-dark);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        z-index: 2000;
        min-width: 250px;
        animation: slideIn 0.3s ease-out;
        cursor: pointer;
    }

    @@keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }

        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    /* Layout */
    .chat-container {
        display: flex;
        height: 100%;
        overflow: hidden;
    }

    .chat-main-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background-color: var(--mica-bg);
    }

    /* Global Status Dot (Used by multiple components) */
    .status-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 6px;
    }

    .status-dot.online {
        background-color: #28a745;
        box-shadow: 0 0 4px #28a745;
    }

    .status-dot.offline {
        background-color: #dc3545;
        opacity: 0.6;
    }

    /* Modal Styles - Global */
    .modal-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(2px);
    }

    .modal-card {
        background-color: var(--mica-bg);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        width: 350px;
        max-width: 90%;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .modal-header {
        padding: 15px;
        border-bottom: 1px solid var(--card-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--mica-alt-bg);
    }

    .modal-body {
        max-height: 400px;
        overflow-y: auto;
        padding: 10px;
    }

    .modal-footer {
        padding: 15px;
        border-top: 1px solid var(--card-border);
        background-color: var(--mica-alt-bg);
        text-align: center;
    }
</style>

@code {
    // State
    private List<ConversationViewModel> Conversations = new List<ConversationViewModel>();
    private ConversationViewModel? SelectedConversation;
    private bool IsNewChatMode = false;
    private bool IsDetailsOpen = false;
    private bool IsAddingParticipants = false;
    private bool _shouldScrollToBottom = false;

    // Delete Modal State
    private bool IsDeleteConfirmOpen = false;
    private ChatMessage? MessageToDelete;

    private Dictionary<string, string> OnlineUsers = new Dictionary<string, string>();
    private Dictionary<string, UserDto> AllUsers = new Dictionary<string, UserDto>(); // UserId -> UserDto
    private HashSet<string> NewChatSelectedUsers = new HashSet<string>();

    private string? currentUserId;
    private string? currentUserName;

    // Setup Safe File Extension Whitelist
    private readonly string[] _allowedExtensions = { ".jpg", ".jpeg", ".png", ".gif", ".webp", ".pdf", ".txt", ".docx",
".xlsx", ".csv" };
    private bool IsConnected => _hubConnection?.State == HubConnectionState.Connected;
    private HubConnection? _hubConnection;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScrollToBottom)
        {
            _shouldScrollToBottom = false;
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatScrollView");
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            currentUserId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
            currentUserName = user.Identity.Name;

            if (currentUserId != null && currentUserName != null)
            {
                ChatState.SetUserOnline(currentUserId, currentUserName);
                await LoadData();
            }
        }

        ChatState.OnChange += HandleStateChange;

        UpdateOnlineUsers();

        var cookies = HttpContextAccessor.HttpContext?.Request.Headers.Cookie.ToString();

        _hubConnection = new HubConnectionBuilder()
        .WithUrl(Navigation.ToAbsoluteUri("/chathub"), options =>
        {
            if (!string.IsNullOrEmpty(cookies))
            {
                options.Headers.Add("Cookie", cookies);
            }
        })
        .WithAutomaticReconnect()
        .Build();

        _hubConnection.On<string, string, string, DateTime, string?, bool, List<string>?, int>("ReceiveMessage",
        HandleMessageReceived);
        _hubConnection.On<int, string>("MessageEdited", HandleMessageEdited);
        _hubConnection.On<int>("MessageDeleted", HandleMessageDeleted);
        _hubConnection.On<int, string, string, string>("ReactionAdded", HandleReactionAdded);
        _hubConnection.On<int, string, string>("ReactionRemoved", HandleReactionRemoved);

        await _hubConnection.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        ChatState.OnChange -= HandleStateChange;

        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }

        if (currentUserId != null) ChatState.SetUserOffline(currentUserId);
    }

    private void HandleStateChange()
    {
        UpdateOnlineUsers();
        InvokeAsync(StateHasChanged);
    }

    private void UpdateOnlineUsers()
    {
        OnlineUsers = ChatState.GetOnlineUsers()
        .Where(u => u.Key != currentUserId)
        .ToDictionary(k => k.Key, v => v.Value);
    }

    private void HandleMessageEdited(int messageId, string newContent)
    {
        InvokeAsync(() =>
        {
            foreach (var conv in Conversations)
            {
                var msg = conv.Messages.FirstOrDefault(m => m.Id == messageId);
                if (msg != null)
                {
                    msg.Message = newContent;
                }
            }
            StateHasChanged();
        });
    }

    private void HandleMessageDeleted(int messageId)
    {
        InvokeAsync(() =>
        {
            foreach (var conv in Conversations)
            {
                var msg = conv.Messages.FirstOrDefault(m => m.Id == messageId);
                if (msg != null)
                {
                    conv.Messages.Remove(msg);
                }
            }
            StateHasChanged();
        });
    }

    private void HandleReactionAdded(int messageId, string userId, string userName, string emoji)
    {
        InvokeAsync(() =>
        {
            foreach (var conv in Conversations)
            {
                var msg = conv.Messages.FirstOrDefault(m => m.Id == messageId);
                if (msg != null)
                {
                    msg.Reactions.Add(new MessageReactionDto { Emoji = emoji, UserId = userId, UserName = userName });
                    StateHasChanged();
                    break;
                }
            }
        });
    }

    private void HandleReactionRemoved(int messageId, string userId, string emoji)
    {
        InvokeAsync(() =>
        {
            foreach (var conv in Conversations)
            {
                var msg = conv.Messages.FirstOrDefault(m => m.Id == messageId);
                if (msg != null)
                {
                    var existing = msg.Reactions.FirstOrDefault(r => r.UserId == userId && r.Emoji == emoji);
                    if (existing != null)
                    {
                        msg.Reactions.Remove(existing);
                        StateHasChanged();
                        break;
                    }
                }
            }
        });
    }

    private async Task LoadData()
    {
        if (currentUserId == null) return;

        // Filter users based on Roles
        var visibleUsersList = await ChatState.GetVisibleUsersAsync(currentUserId);
        AllUsers = visibleUsersList.ToDictionary(u => u.Id, u => u);

        // Fetch history using the new Service method
        var history = await ChatMessageService.GetMessageHistoryAsync(currentUserId);

        // Fetch missing usernames for senders/reactors not in current user's visible list (like historical users/groups)
        var missingUserIds = history.Select(h => h.SenderId)
        .Concat(history.SelectMany(h => h.Reactions).Select(r => r.UserId))
        .Where(id => id != null && id != currentUserId && !AllUsers.ContainsKey(id))
        .Distinct()
        .ToList();

        var extraUsersNames = new Dictionary<string, string>();
        if (currentUserId != null && currentUserName != null)
        {
            extraUsersNames[currentUserId] = currentUserName;
        }

        foreach (var uid in missingUserIds)
        {
            if (uid == null) continue;
            var user = await UserManager.FindByIdAsync(uid);
            extraUsersNames[uid] = user?.UserName ?? "Unknown User";
        }

        Conversations.Clear();

        foreach (var h in history)
        {
            var participants = h.Recipients.Select(r => r.UserId).ToHashSet();
            participants.Add(h.SenderId);

            string convKey;
            // If somehow a message with no recipients exists (old data), skip it
            if (!h.Recipients.Any()) continue;
            // If I am in a conversation with someone I can no longer see (removed from role), should I see the history?
            // Probably yes, history is history. But new messages?
            // For "LoadData", let's keep history if it exists, BUT
            // We need to ensure we don't crash if user map misses them.
            // AllUsers only has visible users.

            convKey = GetConversationKey(participants);

            var conversation = Conversations.FirstOrDefault(c => c.ConversationId == convKey);
            if (conversation == null)
            {
                conversation = new ConversationViewModel
                    {
                        ConversationId = convKey,
                        ParticipantIds = participants.ToList(),
                        DisplayName = GenerateDisplayNameFromMap(participants, AllUsers)
                    };
                Conversations.Add(conversation);
            }

            conversation.Messages.Add(new ChatMessage
                {
                    Id = h.Id,
                    User = AllUsers.TryGetValue(h.SenderId, out var u) ? u.UserName : (extraUsersNames.TryGetValue(h.SenderId, out var
                euName) ? euName : "Unknown User"),
                    Message = h.Message,
                    Timestamp = h.Timestamp,
                    AttachmentUrl = h.AttachmentUrl,
                    IsMine = h.SenderId == currentUserId,
                    SenderId = h.SenderId,
                    Reactions = h.Reactions.Select(r =>
                    {
                        string reactionUserName = "User";
                        if (AllUsers.TryGetValue(r.UserId, out var ru))
                        {
                            reactionUserName = ru.UserName;
                        }
                        else if (extraUsersNames.TryGetValue(r.UserId, out var euReacName))
                        {
                            reactionUserName = euReacName;
                        }
                        return new MessageReactionDto
                        {
                            Emoji = r.Emoji,
                            UserId = r.UserId,
                            UserName = reactionUserName
                        };
                    }).ToList()
                });
        }

        if (SelectedConversation == null)
        {
            SelectedConversation = Conversations.OrderByDescending(c => c.LastActivity).FirstOrDefault();
        }

        if (SelectedConversation != null)
        {
            _shouldScrollToBottom = true;
        }
    }

    private string GetConversationKey(IEnumerable<string> userIds)
    {
        var sorted = userIds.OrderBy(u => u).ToList();
        return string.Join("|", sorted);
    }

    private string GenerateDisplayNameFromMap(HashSet<string> participantIds, Dictionary<string, UserDto> userMap)
    {
        var others = participantIds.Where(u => u != currentUserId).ToList();

        if (others.Count == 0) return "Just You";

        // Get the first user's name
        var firstUid = others[0];
        string firstName = userMap.TryGetValue(firstUid, out var u) && !string.IsNullOrEmpty(u.UserName)
        ? u.UserName
        : firstUid.Substring(0, 8);

        if (others.Count == 1)
        {
            return firstName;
        }
        else
        {
            return $"{firstName} + {others.Count - 1} others";
        }
    }

    private void HandleMessageReceived(string senderId, string senderName, string message, DateTime timestamp, string?
    attachmentUrl, bool _, List<string>? recipientIds, int messageId)
    {
        if (currentUserId == null) return;

        // Ignore Messages with no explicit recipients (Global)
        if (recipientIds == null || !recipientIds.Any()) return;

        // Restriction: Ignore messages from non-visible users (unless it's me)
        if (senderId != currentUserId && !AllUsers.ContainsKey(senderId)) return;

        var participants = new HashSet<string>();
        if (recipientIds != null && recipientIds.Any())
        {
            if (senderId != currentUserId && !recipientIds.Contains(currentUserId))
            {
                return;
            }

            participants = recipientIds.ToHashSet();
            participants.Add(senderId);
        }

        string convKey = GetConversationKey(participants);

        var conversation = Conversations.FirstOrDefault(c => c.ConversationId == convKey);

        if (conversation == null)
        {
            conversation = new ConversationViewModel
                {
                    ConversationId = convKey,
                    ParticipantIds = participants.ToList(),
                    DisplayName = GenerateDisplayNameFromMap(participants, AllUsers)
                };

            Conversations.Add(conversation);
        }

        var msg = new ChatMessage
            {
                Id = messageId,
                User = senderName ?? senderId,
                Message = message,
                Timestamp = timestamp,
                AttachmentUrl = attachmentUrl,
                IsMine = senderId == currentUserId,
                SenderId = senderId,
                Reactions = new List<MessageReactionDto>()
            };

        conversation.Messages.Add(msg);

        InvokeAsync(async () =>
        {
            StateHasChanged();

            if (senderId != currentUserId)
            {
                bool isLookingAtIt = SelectedConversation != null && SelectedConversation.ConversationId == convKey;

                if (!isLookingAtIt)
                {
                    ShowNotification($"New message from {senderName ?? "User"}", conversation!.DisplayName);
                }
                else
                {
                    // Delay slightly to ensure UI has rendered the message
                    await Task.Delay(50);
                    await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatScrollView");
                }
            }
            else
            {
                // Message from me (e.g. from another tab/device)
                await Task.Delay(50);
                await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatScrollView");
            }
        });
    }

    // Notification State
    private bool IsNotificationVisible = false;
    private string NotificationMessage = string.Empty;
    private Guid CurrentNotificationId;

    private void ShowNotification(string user, string context)
    {
        NotificationMessage = $"{user} in {context}";
        IsNotificationVisible = true;
        var notifId = Guid.NewGuid();
        CurrentNotificationId = notifId;
        StateHasChanged();

        _ = Task.Delay(5000).ContinueWith(t =>
        {
            InvokeAsync(() =>
    {
    if (IsNotificationVisible && CurrentNotificationId == notifId)
    {
        IsNotificationVisible = false;
        StateHasChanged();
    }
            });
        });
    }

    private void CloseNotification()
    {
        IsNotificationVisible = false;
    }

    // Actions
    private async Task OnConversationSelected(ConversationViewModel c)
    {
        SelectedConversation = c;
        IsNewChatMode = false;
        IsAddingParticipants = false;

        await Task.Delay(50);
        await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatScrollView");
    }

    private void OnStartNewChat()
    {
        SelectedConversation = null;
        IsNewChatMode = true;
        IsAddingParticipants = false;
        NewChatSelectedUsers.Clear();
    }

    private void ToggleDetails()
    {
        IsDetailsOpen = !IsDetailsOpen;
    }

    private void AddUserToCurrentChat()
    {
        IsDetailsOpen = false;

        if (SelectedConversation == null) return;

        IsNewChatMode = true;
        IsAddingParticipants = true;
        NewChatSelectedUsers.Clear();
        foreach (var p in SelectedConversation.ParticipantIds.Where(id => id != currentUserId))
        {
            NewChatSelectedUsers.Add(p);
        }
        SelectedConversation = null;
    }

    private void OnToggleNewChatUser(string userId)
    {
        if (NewChatSelectedUsers.Contains(userId)) NewChatSelectedUsers.Remove(userId);
        else NewChatSelectedUsers.Add(userId);
    }

    // Updated Send logic to accept message string
    private async Task HandleSend(string message)
    {
        await SendMessageInternal(message, false);
    }

    private async Task OnStartChat(string message)
    {
        await SendMessageInternal(message, true);
    }

    private async Task SendMessageInternal(string message, bool isNewChat)
    {
        if (!string.IsNullOrWhiteSpace(message) && currentUserId != null)
        {
            List<string> recipients = new();
            HashSet<string> participants = new();

            if (isNewChat)
            {
                recipients = NewChatSelectedUsers.ToList();
                participants = NewChatSelectedUsers.ToHashSet();
                participants.Add(currentUserId);
            }
            else if (SelectedConversation != null)
            {
                recipients = SelectedConversation.ParticipantIds.Where(id => id != currentUserId).ToList();
            }
            else return;

            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
            {
                await _hubConnection.SendAsync("SendMessage", message, recipients, null);
            }

            if (isNewChat)
            {
                // Force Select the conversation we just started
                string convKey = GetConversationKey(participants);
                var conversation = Conversations.FirstOrDefault(c => c.ConversationId == convKey);

                if (conversation == null)
                {
                    conversation = new ConversationViewModel
                        {
                            ConversationId = convKey,
                            ParticipantIds = participants.ToList(),
                            DisplayName = GenerateDisplayNameFromMap(participants, AllUsers)
                        };
                    Conversations.Add(conversation);
                }

                SelectedConversation = conversation;
                IsNewChatMode = false;
            }

            // Scroll to bottom immediately upon sending
            await Task.Delay(50);
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatScrollView");
        }
    }

    private async Task OnFileUpload(InputFileChangeEventArgs e)
    {
        var file = e.File;

        if (file != null && currentUserId != null)
        {
            var extension = Path.GetExtension(file.Name).ToLowerInvariant();
            if (!_allowedExtensions.Contains(extension))
            {
                ShowNotification("System", $"File type {extension} is not allowed for security reasons.");
                return;
            }

            var uploadPath = Path.Combine("wwwroot", "uploads");
            if (!Directory.Exists(uploadPath)) Directory.CreateDirectory(uploadPath);
            var fileName = $"{Guid.NewGuid()}{extension}";
            var filePath = Path.Combine(uploadPath, fileName);
            await using var fs = new FileStream(filePath, FileMode.Create);
            await file.OpenReadStream(10 * 1024 * 1024).CopyToAsync(fs);
            var attachmentUrl = $"/uploads/{fileName}";

            List<string> recipients = new();
            if (SelectedConversation != null)
            {
                recipients = SelectedConversation.ParticipantIds.Where(id => id != currentUserId).ToList();
            }
            // Note: If uploading in New Chat, we need specific logic? Assuming works same as send.
            else if (IsNewChatMode)
            {
                recipients = NewChatSelectedUsers.ToList();
            }

            if (recipients.Count > 0)
            {
                if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
                {
                    await _hubConnection.SendAsync("SendMessage", $"Sent attachment: {file.Name}", recipients, attachmentUrl);
                }
            }

            if (IsNewChatMode) IsNewChatMode = false;
        }
    }

    // Reaction Actions
    private async Task HandleToggleReaction((ChatMessage msg, string emoji) args)
    {
        if (args.msg.Reactions == null)
        {
            args.msg.Reactions = new List<MessageReactionDto>();
        }

        var existing = args.msg.Reactions.FirstOrDefault(r => r.Emoji == args.emoji && r.UserId == currentUserId);
        if (existing != null)
        {
            await HandleRemoveReaction(args.msg, args.emoji);
        }
        else
        {
            await HandleAddReaction(args.msg, args.emoji);
        }
    }

    private async Task HandleAddReaction(ChatMessage msg, string emoji)
    {
        if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
        {
            await _hubConnection.SendAsync("AddReaction", msg.Id, emoji);
        }
    }

    private async Task HandleRemoveReaction(ChatMessage msg, string emoji)
    {
        if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
        {
            await _hubConnection.SendAsync("RemoveReaction", msg.Id, emoji);
        }
    }

    private ActiveChatView? activeChatView;

    private async Task HandleReply(ChatMessage msg)
    {
        if (activeChatView != null)
        {
            await activeChatView.SetReplyMessageAsync(msg);
        }
    }

    // UI Helpers for Edit/Delete
    private void StartEdit(ChatMessage msg)
    {
        msg.IsEditing = true;
        msg.EditBuffer = msg.Message;
    }

    private void CancelEdit(ChatMessage msg)
    {
        msg.IsEditing = false;
    }

    private async Task SaveEdit(ChatMessage msg)
    {
        if (msg.EditBuffer == msg.Message)
        {
            msg.IsEditing = false;
            return;
        }

        if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
        {
            await _hubConnection.SendAsync("EditMessage", msg.Id, msg.EditBuffer);
        }

        msg.IsEditing = false;
    }

    private void DeleteMessage(ChatMessage msg)
    {
        MessageToDelete = msg;
        IsDeleteConfirmOpen = true;
    }

    private void CancelDelete()
    {
        IsDeleteConfirmOpen = false;
        MessageToDelete = null;
    }

    private async Task ConfirmDelete()
    {
        if (MessageToDelete != null)
        {
            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
            {
                await _hubConnection.SendAsync("DeleteMessage", MessageToDelete.Id);
            }
            CancelDelete();
        }
    }
}
