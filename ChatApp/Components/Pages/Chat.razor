@page "/chat"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.SignalR.Client
@using ChatApp.Services
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Authorization
@using ChatApp.Models
@using ChatApp.Components.Chat
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ChatStateService ChatState
@inject IJSRuntime JSRuntime
@inject IServiceScopeFactory ScopeFactory
@attribute [Authorize]
@implements IAsyncDisposable

<PageTitle>Chat</PageTitle>

<div class="chat-container">
    <!-- Sidebar -->
    <ConversationList Conversations="Conversations" SelectedConversation="SelectedConversation"
        CurrentUserId="@currentUserId" OnlineUsers="OnlineUsers" OnConversationSelected="OnConversationSelected"
        OnStartNewChat="OnStartNewChat" />

    <!-- Main Chat Area -->
    <div class="chat-main-area">
        @if (IsNewChatMode)
        {
            <NewChatView AllUsers="AllUsers" OnlineUsers="OnlineUsers" SelectedUsers="NewChatSelectedUsers"
                IsAddingParticipants="IsAddingParticipants" IsConnected="IsConnected" OnToggleUser="OnToggleNewChatUser"
                OnStart="OnStartChat" OnFileUpload="OnFileUpload" />
        }
        else if (SelectedConversation != null)
        {
            <ActiveChatView Conversation="SelectedConversation" IsConnected="IsConnected" OnToggleDetails="ToggleDetails"
                OnSend="HandleSend" OnFileUpload="OnFileUpload" OnStartEdit="StartEdit" OnDelete="DeleteMessage"
                OnSaveEdit="SaveEdit" OnCancelEdit="CancelEdit" />

            <ChatDetailsModal IsOpen="IsDetailsOpen" Conversation="SelectedConversation" AllUsers="AllUsers"
                OnlineUsers="OnlineUsers" CurrentUserId="@currentUserId" OnClose="ToggleDetails"
                OnAddPeople="AddUserToCurrentChat" />

            <DeleteConfirmationModal IsOpen="IsDeleteConfirmOpen" Message="MessageToDelete" OnConfirm="ConfirmDelete"
                OnCancel="CancelDelete" />
        }
        else
        {
            <div class="d-flex flex-column align-items-center justify-content-center h-100 text-muted">
                <p class="fs-4">Select a conversation or start a new one.</p>
            </div>
        }
    </div>
</div>

@if (IsNotificationVisible)
{
    <div class="toast-notification">
        <div class="d-flex align-items-center justify-content-between">
            <span>@NotificationMessage</span>
            <button class="btn-close btn-close-white ms-3" @onclick="CloseNotification"></button>
        </div>
    </div>
}

<style>
    /* Global Toast */
    .toast-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: var(--accent-dark);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        z-index: 2000;
        min-width: 250px;
        animation: slideIn 0.3s ease-out;
        cursor: pointer;
    }

    @@keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }

        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    /* Layout */
    .chat-container {
        display: flex;
        height: 100%;
        overflow: hidden;
    }

    .chat-main-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background-color: var(--mica-bg);
    }

    /* Global Status Dot (Used by multiple components) */
    .status-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 6px;
    }

    .status-dot.online {
        background-color: #28a745;
        box-shadow: 0 0 4px #28a745;
    }

    .status-dot.offline {
        background-color: #dc3545;
        opacity: 0.6;
    }

    /* Modal Styles - Global */
    .modal-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(2px);
    }

    .modal-card {
        background-color: var(--mica-bg);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        width: 350px;
        max-width: 90%;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .modal-header {
        padding: 15px;
        border-bottom: 1px solid var(--card-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--mica-alt-bg);
    }

    .modal-body {
        max-height: 400px;
        overflow-y: auto;
        padding: 10px;
    }

    .modal-footer {
        padding: 15px;
        border-top: 1px solid var(--card-border);
        background-color: var(--mica-alt-bg);
        text-align: center;
    }
</style>

@code {
    // State
    private List<ConversationViewModel> Conversations = new List<ConversationViewModel>();
    private ConversationViewModel? SelectedConversation;
    private bool IsNewChatMode = false;
    private bool IsDetailsOpen = false;
    private bool IsAddingParticipants = false;

    // Delete Modal State
    private bool IsDeleteConfirmOpen = false;
    private ChatMessage? MessageToDelete;

    // We don't need 'messageInput' state here anymore as it's local to ChatInput component
    // BUT NewChatView passes it up? No, event callbacks pass the string.

    private Dictionary<string, string> OnlineUsers = new Dictionary<string, string>();
    private Dictionary<string, string> AllUsers = new Dictionary<string, string>(); // UserId -> UserName
    private HashSet<string> NewChatSelectedUsers = new HashSet<string>();

    private string? currentUserId;
    private string? currentUserName;
    private bool IsConnected = true;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            currentUserId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
            currentUserName = user.Identity.Name;

            if (currentUserId != null && currentUserName != null)
            {
                ChatState.SetUserOnline(currentUserId, currentUserName);
                await LoadData();
            }
        }

        ChatState.OnChange += HandleStateChange;
        ChatState.OnMessageReceived += HandleMessageReceived;
        ChatState.OnMessageEdited += HandleMessageEdited;
        ChatState.OnMessageDeleted += HandleMessageDeleted;

        UpdateOnlineUsers();
    }

    public async ValueTask DisposeAsync()
    {
        ChatState.OnChange -= HandleStateChange;
        ChatState.OnMessageReceived -= HandleMessageReceived;
        ChatState.OnMessageEdited -= HandleMessageEdited;
        ChatState.OnMessageDeleted -= HandleMessageDeleted;

        if (currentUserId != null) ChatState.SetUserOffline(currentUserId);
    }

    private void HandleStateChange()
    {
        UpdateOnlineUsers();
        InvokeAsync(StateHasChanged);
    }

    private void UpdateOnlineUsers()
    {
        OnlineUsers = ChatState.GetOnlineUsers()
        .Where(u => u.Key != currentUserId)
        .ToDictionary(k => k.Key, v => v.Value);
    }

    private void HandleMessageEdited(int messageId, string newContent)
    {
        InvokeAsync(() =>
        {
            foreach (var conv in Conversations)
            {
                var msg = conv.Messages.FirstOrDefault(m => m.Id == messageId);
                if (msg != null)
                {
                    msg.Message = newContent;
                }
            }
            StateHasChanged();
        });
    }

    private void HandleMessageDeleted(int messageId)
    {
        InvokeAsync(() =>
        {
            foreach (var conv in Conversations)
            {
                var msg = conv.Messages.FirstOrDefault(m => m.Id == messageId);
                if (msg != null)
                {
                    conv.Messages.Remove(msg);
                }
            }
            StateHasChanged();
        });
    }

    private async Task LoadData()
    {
        if (currentUserId == null) return;

        using (var scope = ScopeFactory.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<ChatApp.Data.ApplicationDbContext>();

            AllUsers = await db.Users
            .Where(u => u.Id != currentUserId)
            .ToDictionaryAsync(u => u.Id, u => u.UserName ?? "Unknown");

            var history = await db.ChatMessages
            .Include(m => m.Recipients)
            .Where(m => !m.Recipients.Any() || m.SenderId == currentUserId || m.Recipients.Any(r => r.UserId == currentUserId))
            .OrderBy(m => m.Timestamp)
            .ToListAsync();

            Conversations.Clear();

            foreach (var h in history)
            {
                var participants = h.Recipients.Select(r => r.UserId).ToHashSet();
                participants.Add(h.SenderId);

                string convKey;
                if (!h.Recipients.Any())
                {
                    convKey = "global";
                }
                else
                {
                    convKey = GetConversationKey(participants);
                }

                var conversation = Conversations.FirstOrDefault(c => c.ConversationId == convKey);
                if (conversation == null)
                {
                    conversation = new ConversationViewModel
                        {
                            ConversationId = convKey,
                            ParticipantIds = participants.ToList(),
                            DisplayName = GenerateDisplayNameFromMap(participants, convKey == "global", AllUsers)
                        };
                    Conversations.Add(conversation);
                }

                conversation.Messages.Add(new ChatMessage
                    {
                        Id = h.Id,
                        User = AllUsers.TryGetValue(h.SenderId, out var name) ? name : h.SenderName,
                        Message = h.Message,
                        Timestamp = h.Timestamp,
                        AttachmentUrl = h.AttachmentUrl,
                        IsMine = h.SenderId == currentUserId,
                        SenderId = h.SenderId
                    });
            }

            if (SelectedConversation == null)
            {
                SelectedConversation = Conversations.OrderByDescending(c => c.LastActivity).FirstOrDefault();
            }
        }
    }

    private string GetConversationKey(IEnumerable<string> userIds)
    {
        var sorted = userIds.OrderBy(u => u).ToList();
        return string.Join("|", sorted);
    }

    private string GenerateDisplayNameFromMap(HashSet<string> participantIds, bool isGlobal, Dictionary<string, string>
    userMap)
    {
        if (isGlobal) return "General (Everyone)";

        var others = participantIds.Where(u => u != currentUserId).ToList();

        if (others.Count == 0) return "Just You";

        // Get the first user's name
        var firstUid = others[0];
        string firstName = userMap.TryGetValue(firstUid, out var name) && !string.IsNullOrEmpty(name)
        ? name
        : firstUid.Substring(0, 8);

        if (others.Count == 1)
        {
            return firstName;
        }
        else
        {
            return $"{firstName} + {others.Count - 1} others";
        }
    }

    private void HandleMessageReceived(string senderId, string senderName, string message, DateTime timestamp, string?
    attachmentUrl, bool _, List<string>? recipientIds, int messageId)
    {
        if (currentUserId == null) return;

        var participants = new HashSet<string>();
        if (recipientIds != null && recipientIds.Any())
        {
            if (senderId != currentUserId && !recipientIds.Contains(currentUserId))
            {
                return;
            }

            participants = recipientIds.ToHashSet();
            participants.Add(senderId);
        }
        else
        {
            participants.Add("global");
        }

        string convKey = (recipientIds == null || !recipientIds.Any()) ? "global" : GetConversationKey(participants);

        var conversation = Conversations.FirstOrDefault(c => c.ConversationId == convKey);

        if (conversation == null)
        {
            conversation = new ConversationViewModel
                {
                    ConversationId = convKey,
                    ParticipantIds = participants.Where(p => p != "global").ToList(),
                    DisplayName = GenerateDisplayNameFromMap(participants, convKey == "global", AllUsers)
                };

            Conversations.Add(conversation);
        }

        var msg = new ChatMessage
            {
                Id = messageId, 
                User = senderName ?? senderId,
                Message = message,
                Timestamp = timestamp,
                AttachmentUrl = attachmentUrl,
                IsMine = senderId == currentUserId,
                SenderId = senderId
            };

        conversation.Messages.Add(msg);

        InvokeAsync(async () =>
        {
            StateHasChanged();

            if (senderId != currentUserId)
            {
                bool isLookingAtIt = SelectedConversation != null && SelectedConversation.ConversationId == convKey;

                if (!isLookingAtIt)
                {
                    ShowNotification($"New message from {senderName ?? "User"}", conversation!.DisplayName);
                }
            }
        });
    }

    // Notification State
    private bool IsNotificationVisible = false;
    private string NotificationMessage = string.Empty;
    private Guid CurrentNotificationId;

    private void ShowNotification(string user, string context)
    {
        NotificationMessage = $"{user} in {context}";
        IsNotificationVisible = true;
        var notifId = Guid.NewGuid();
        CurrentNotificationId = notifId;
        StateHasChanged();

        _ = Task.Delay(5000).ContinueWith(t =>
        {
            InvokeAsync(() =>
    {
    if (IsNotificationVisible && CurrentNotificationId == notifId)
    {
        IsNotificationVisible = false;
        StateHasChanged();
    }
            });
        });
    }

    private void CloseNotification()
    {
        IsNotificationVisible = false;
    }

    // Actions
    private void OnConversationSelected(ConversationViewModel c)
    {
        SelectedConversation = c;
        IsNewChatMode = false;
        IsAddingParticipants = false;
    }

    private void OnStartNewChat()
    {
        SelectedConversation = null;
        IsNewChatMode = true;
        IsAddingParticipants = false;
        NewChatSelectedUsers.Clear();
    }

    private void ToggleDetails()
    {
        IsDetailsOpen = !IsDetailsOpen;
    }

    private void AddUserToCurrentChat()
    {
        IsDetailsOpen = false;

        if (SelectedConversation == null) return;

        IsNewChatMode = true;
        IsAddingParticipants = true;
        NewChatSelectedUsers.Clear();
        foreach (var p in SelectedConversation.ParticipantIds.Where(id => id != currentUserId))
        {
            NewChatSelectedUsers.Add(p);
        }
        SelectedConversation = null;
    }

    private void OnToggleNewChatUser(string userId)
    {
        if (NewChatSelectedUsers.Contains(userId)) NewChatSelectedUsers.Remove(userId);
        else NewChatSelectedUsers.Add(userId);
    }

    // Updated Send logic to accept message string
    private void HandleSend(string message)
    {
        SendMessageInternal(message, false);
    }

    private void OnStartChat(string message)
    {
        SendMessageInternal(message, true);
    }

    private void SendMessageInternal(string message, bool isNewChat)
    {
        if (!string.IsNullOrWhiteSpace(message) && currentUserId != null)
        {
            List<string> recipients = new();

            if (isNewChat)
            {
                recipients = NewChatSelectedUsers.ToList();
            }
            else if (SelectedConversation != null)
            {
                if (SelectedConversation.ConversationId == "global")
                {
                    recipients = new List<string>();
                }
                else
                {
                    recipients = SelectedConversation.ParticipantIds.Where(id => id != currentUserId).ToList();
                }
            }
            else return;

            ChatState.BroadcastMessage(currentUserId, currentUserName ?? "Unknown", message, recipients, null);

            if (isNewChat)
            {
                IsNewChatMode = false;
            }
        }
    }

    private async Task OnFileUpload(InputFileChangeEventArgs e)
    {
        var file = e.File;

        if (file != null && currentUserId != null)
        {
            var uploadPath = Path.Combine("wwwroot", "uploads");
            if (!Directory.Exists(uploadPath)) Directory.CreateDirectory(uploadPath);
            var fileName = $"{Guid.NewGuid()}{Path.GetExtension(file.Name)}";
            var filePath = Path.Combine(uploadPath, fileName);
            await using var fs = new FileStream(filePath, FileMode.Create);
            await file.OpenReadStream(10 * 1024 * 1024).CopyToAsync(fs);
            var attachmentUrl = $"/uploads/{fileName}";

            List<string> recipients = new();
            if (selectedConversationIsGlobal()) recipients = new List<string>();
            else if (SelectedConversation != null) recipients = SelectedConversation.ParticipantIds.Where(id => id !=
            currentUserId).ToList();
            // Note: If uploading in New Chat, we need specific logic? Assuming works same as send.
            else if (IsNewChatMode) recipients = NewChatSelectedUsers.ToList();

            ChatState.BroadcastMessage(currentUserId, currentUserName ?? "Unknown", $"Sent attachment: {file.Name}", recipients,
            attachmentUrl);

            if (IsNewChatMode) IsNewChatMode = false;
        }
    }

    private bool selectedConversationIsGlobal() => SelectedConversation?.ConversationId == "global";

    // UI Helpers for Edit/Delete
    private void StartEdit(ChatMessage msg)
    {
        msg.IsEditing = true;
        msg.EditBuffer = msg.Message;
    }

    private void CancelEdit(ChatMessage msg)
    {
        msg.IsEditing = false;
    }

    private async Task SaveEdit(ChatMessage msg)
    {
        if (msg.EditBuffer == msg.Message)
        {
            msg.IsEditing = false;
            return;
        }

        await ChatState.EditMessage(msg.Id, msg.EditBuffer);
        msg.IsEditing = false;
    }

    private void DeleteMessage(ChatMessage msg)
    {
        MessageToDelete = msg;
        IsDeleteConfirmOpen = true;
    }

    private void CancelDelete()
    {
        IsDeleteConfirmOpen = false;
        MessageToDelete = null;
    }

    private async Task ConfirmDelete()
    {
        if (MessageToDelete != null)
        {
            await ChatState.DeleteMessage(MessageToDelete.Id);
            CancelDelete();
        }
    }
}
